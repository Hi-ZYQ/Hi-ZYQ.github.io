<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多表查询]]></title>
    <url>%2F2019%2F10%2F17%2F%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[今日内容 多表查询 事务 DCL 多表查询 查询语法 123456select 列名列表from 表名列表where... * 笛卡尔积: 有两个集合A,B,取这两个集合的所有组成情况 要完成多表查询,需要消除无用的数据 多表查询分类 内连接查询: 隐式内敛及:使用where条件消除无用的信息 123456789SELECT t1.NAME, -- 员工表的姓名 t1.gender, -- 员工表的性别 t2.NAME -- 部门表姓名from emp t1, dept t2where t1.dept_id = t2.id; * 显示内连接: * 语法:`select`字段列表 `from` 表名1 `inner` `join` 表名2 1SELECT * FROM emp [INNER] JOIN dept ON emp.dept_id = dept.id; * 内连接查询: * 从哪些表中查数据 * 查询条件是什么 * 查询哪些字段 外连接查询: 左外连接: 语法:select 字段列表 from 表1 left [outer] join 表2 on 条件; 查询的是左表所有数据以及其交集部分 右外连接 语法:select 字段列表 from 表1 right [outer] join 表2 on 条件; 子查询: 概念:查询中嵌套查询,成为子查询. 1234567-- 例子-- 查询最高的工资SELECT MAX(salary) FROM emp;-- 查询员工信息并且工资等于9000的select * FROM emp where emp.salary = 9000;-- 一条sql语句完成这个操作select * FROM emp where emp.salary = (SELECT MAX(salary) FROM emp); 子查询的不同情况 子查询的结果是单行单列的: 子查询可以作为条件,使用运算符去判断,运算符: &gt; &lt; &gt;= &lt;= = 12-- 例子查询工资小于平均工资的人select * from emp where emp.salary &lt; (select avg(salary) from emp); 子查询的结果是多行单列的: 子查询可以作为条件的可以采用in作为条件 123456-- 查询财务部和市场部所有的员工信息select id from dept WHERE NAME = &apos;财务部&apos; or NAME =&apos;市场部&apos;;select * from emp where dept_id = 3 or dept_id = 2;select * from emp where dept_id in (3,2);-- 子查询select * from emp where dept_id in (select id from dept WHERE NAME = &apos;财务部&apos; or NAME =&apos;市场部&apos;); 子查询的结果是多行多列的: 子查询可以作为一张虚拟表 1234-- 子查询-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息select * from dept t1,(select * from emp where emp.join_date &gt; &apos;2011-11-11&apos;) t2where t1.id = t2.dept_id; 普通内连接 1select * from emp t1,dept t2 where t1.dept_id = t2.id and t1.dept_date &gt; &apos;2011-11-11&apos;; 多表查询练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178-- 部门表CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地);-- 添加4个部门INSERT INTO dept(id,dname,loc) VALUES (10,&apos;教研部&apos;,&apos;北京&apos;),(20,&apos;学工部&apos;,&apos;上海&apos;),(30,&apos;销售部&apos;,&apos;广州&apos;),(40,&apos;财务部&apos;,&apos;深圳&apos;);-- 职务表，职务名称，职务描述CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50));-- 添加4个职务INSERT INTO job (id, jname, description) VALUES(1, &apos;董事长&apos;, &apos;管理整个公司，接单&apos;),(2, &apos;经理&apos;, &apos;管理部门员工&apos;),(3, &apos;销售员&apos;, &apos;向客人推销产品&apos;),(4, &apos;文员&apos;, &apos;使用办公软件&apos;);-- 员工表CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id));-- 添加员工INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,&apos;孙悟空&apos;,4,1004,&apos;2000-12-17&apos;,&apos;8000.00&apos;,NULL,20), (1002,&apos;卢俊义&apos;,3,1006,&apos;2001-02-20&apos;,&apos;16000.00&apos;,&apos;3000.00&apos;,30),(1003,&apos;林冲&apos;,3,1006,&apos;2001-02-22&apos;,&apos;12500.00&apos;,&apos;5000.00&apos;,30),(1004,&apos;唐僧&apos;,2,1009,&apos;2001-04-02&apos;,&apos;29750.00&apos;,NULL,20),(1005,&apos;李逵&apos;,4,1006,&apos;2001-09-28&apos;,&apos;12500.00&apos;,&apos;14000.00&apos;,30),(1006,&apos;宋江&apos;,2,1009,&apos;2001-05-01&apos;,&apos;28500.00&apos;,NULL,30),(1007,&apos;刘备&apos;,2,1009,&apos;2001-09-01&apos;,&apos;24500.00&apos;,NULL,10),(1008,&apos;猪八戒&apos;,4,1004,&apos;2007-04-19&apos;,&apos;30000.00&apos;,NULL,20),(1009,&apos;罗贯中&apos;,1,NULL,&apos;2001-11-17&apos;,&apos;50000.00&apos;,NULL,10),(1010,&apos;吴用&apos;,3,1006,&apos;2001-09-08&apos;,&apos;15000.00&apos;,&apos;0.00&apos;,30),(1011,&apos;沙僧&apos;,4,1004,&apos;2007-05-23&apos;,&apos;11000.00&apos;,NULL,20),(1012,&apos;李逵&apos;,4,1006,&apos;2001-12-03&apos;,&apos;9500.00&apos;,NULL,30),(1013,&apos;小白龙&apos;,4,1004,&apos;2001-12-03&apos;,&apos;30000.00&apos;,NULL,20),(1014,&apos;关羽&apos;,4,1007,&apos;2002-01-23&apos;,&apos;13000.00&apos;,NULL,10);-- 工资等级表CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资);-- 添加5个工资等级INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000),(2,12010,14000),(3,14010,20000),(4,20010,30000),(5,30010,99990);-- 需求：-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述/* 分析: 1,查询员工编号，员工姓名，工资需要查询emp 职务名称，职务描述需要查询job 2,查询条件 emp.job_id = job.id*/SELECT t1.id, t1.ename, t1.salary, t2.jname, t2.descriptionFROM emp t1,job t2WHERE t1.job_id = t2.id;-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置SELECT t1.id, t1.ename, t1.salary, t2.jname, t2.description, t3.dname, t3.locFROM emp t1,job t2,dept t3WHERE t1.job_id = t2.id and t1.dept_id = t3.id;-- 3.查询员工姓名，工资，工资等级SELECT t1.ename, t1.salary, t2.gradeFROM emp t1,salarygrade t2WHERE t1.salary BETWEEN t2.losalary AND t2.hisalary;-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级SELECT t1.ename, t1.salary, t2.jname, t2.description, t3.dname, t3.loc, t4.gradeFROM emp t1,job t2,dept t3,salarygrade t4WHERE t1.job_id = t2.id and t1.dept_id = t3.id and t1.salary BETWEEN t4.losalary AND t4 .hisalary;-- 5.查询出部门编号、部门名称、部门位置、部门人数/* 分析: 1.部门编号、部门名称、部门位置dept表. 部门人数 emp表 2.使用分组查询,按照emp.dept_id完成分组查询count(id) 3.使用子查询将第二部的查询结果dept进行关联*/SELECT t1.id,t1.dname,t1.loc,t2.totalFROM dept t1, (SELECT dept_id,COUNT(id) total from emp GROUP BY dept_id) t2WHERE t1.id = t2.dept_id; -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询/* 分析: 1.姓名 emp, 直接上级姓名 emp emp表的id和mgr自关联 2.条件 emp.id = emp.mgr 3.查询左表的所有数据和交集数据 (使用左外连接查询)*/SELECT t1.ename, t1.mgr, t2.id, t2.enamefrom emp t1LEFT JOIN emp t2on t1.mgr = t2.id; 事务 事务的基本介绍 概念 : 如果一个包含多个步骤的业务操作被事务管理,那么这些操作要么同事成功,要么同事失败. 操作 : 开始事务 : start transaction; 回滚 :rollback; 提交 :commit; 12345678910111213-- 开启事务START TRANSACTION;-- 张三账户减500UPDATE account SET balance = balance - 500 WHERE NAME = &apos;zhangsan&apos;;-- 李四账户加500UPDATE account SET balance = balance + 500 WHERE NAME = &apos;lisi&apos;;-- 发现没问题提交COMMIT;-- 发现出错误回滚事务ROLLBACK; MySQL数据库中事务默认自动提交 事务提交的两种方式: 自动提交 :mysql就是自动提交的 一条DML(增删改)语句会自动提交一次事务 手动提交 : oracle 数据库默认是手动提交事务的. 需要开启事务,在提交 修改事务的默认提交方式: 查看事务的默认提交方式 1SELECT @@autocommit; -- 1代表自动提交 0 代表手动提交 修改默认提交方式 1set @@autocommit = 0; 事务的四大特征 原子性 : 他是不可分割的最小操作单位,要么同时成功要么同时失败. 持久性 : 当事务提交和回滚后,数据库会发生持久化的保存数据 隔离性 : 多个事务之间.相互独立 一致性 ：事务操作前后，数据总量不变 事务的隔离级别(了解) 概念 ：多个事务之前隔离的，相互独立的。如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题了 存在问题： 脏读：一个事务，读取到另一个事务中没有提到的数据 不可重复读（虚读）：再同一个事务中两次读取到的数据不一样 幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加一条数据，则第一个事务查询不到自己的修改。 隔离级别 read uncommitted读未提交 产生的问题：脏读：不可重复读（虚读）幻读： read committed读以提交（Oracle默认） 产生的问题：不可重复读（虚读）幻读： repeatable read可重复读（MySQL默认） 产生的问题：幻读 serializable串行话 可以解决所有的问题 注意：隔离级别从小到大，安全性越来越高，效率越来越低 数据库查询隔离级别: select @@tx_isolation; 数据库设置隔离级别: set global transaction isolation level级别字符串; 演示: 12345set global transaction isolation level read uncommitted;start transaction;-- 转账操作update account set balance = balance - 100 where id = 1;update account set balance = balance + 100 where id = 2; DCL SQL分类: DDL:操作数据库和表 DML:增删改表中的数据 DQL查询表中的数据 DCL:管理用户,授权 DBA:数据库管理员 DCL:管理用户,授权 管理用户 用户的添加 删除用户 修改用户密码 12345UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;;UPDATE USER SET PASSWORD = PASSWORD(&apos;abc&apos;) WHERE USER = &apos;xiaohua&apos;;set PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;);set PASSWORD FOR &apos;小志&apos;@&apos;localhost&apos; = PASSWORD(&apos;abc&apos;); 在mysql中忘记root密码? cmd -- &gt; net stop mysql停止mysql服务(需要管理员) 启动mysql服务: mysqld --skip-grant-tables 打开新的cmd窗口直接输入mysql命令回车就可以登录成功 use mysql; update user set password = password(‘你的新密码’)where user = &#39;root&#39;; 关闭窗口打开任务管理器手动结束mysqld.exe的进程 启动mysql服务 使用新密码登录 查询用户 1234567891011-- % 通配符 可以在所有主机使用use mysql;SELECT * FROM `user`;CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED by &apos;密码&apos;;CREATE USER &apos;小志&apos;@&apos;localhost&apos; IDENTIFIED by &apos;123&apos;;CREATE USER &apos;小花&apos;@&apos;%&apos; IDENTIFIED by &apos;123&apos;;-- 删除用户DROP USER &apos;用户名&apos;@&apos;主机名&apos;;DROP USER &apos;小花&apos;@&apos;%&apos;; 权限管理: 查询权限: 1234-- 查询权限SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;;SHOW GRANTS FOR &apos;小志&apos;@&apos;localhost&apos;;SHOW GRANTS FOR &apos;root&apos;@&apos;%&apos;; * 授予权限: 123456-- 授予权限GRANT 权限列表 ON 数据库名.表名 TO &apos;用户名&apos;@&apos;主机名&apos;;GRANT select,DELETE,UPDATE ON db3.account TO &apos;小志&apos;@&apos;localhost&apos;;-- 给小花用户授予所有权限GRANT ALL ON *.* TO &apos;xiaohua&apos;@&apos;%&apos;; * 撤销权限: 12-- 撤销权限:REVOKE 权限列表 on 数据库名称.表名 from &apos;用户名&apos;@&apos;主机名&apos;;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>多表查询,事务,DCL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础]]></title>
    <url>%2F2019%2F09%2F25%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[今日内容数据库的基本概念 数据库的英文单词: DateBase 简称 : DB 什么是数据库? 用来储存和管理数据的仓库. 数据库的特点: 持久的存储数据.其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 —SQL 常见的数据库软件–参考文档 MySQL数据库软件 安装 参见文档 卸载 去mysql的安装目录找到my.ini文件 复制datadir = ...去文件夹找 卸载MySQL 配置 MySQL服务启动 手动 cmd窗口建立一个命令,services.msc cmd使用管理员权限打开cmd net start mysql启动mysql服务 net stop mysql 关闭mysql服务 MySQL登录 mysql -uroot -proot mysql -hip地址 -uroot -p链接目标密码 mysql --host=IP地址--user=root --password=root MySQL退出 exit quit 配置文件my.ini MySQL数据目录 几个概念 数据库: 文件夹 表: 文件 数据: 数据 SQL 什么是SQL? Structured Query Language : 结构化查询语言 其实就是定义了操作所有关系型数据库的规则.每一种数据库操作的方式存在不一样的地方,成为”方言” SQL通用语法 SQL语句可以单行或多行书写,以分号结尾. 可以使用空格和缩进增进可读性 MySQL数据库的SQL语句不区分大小写,关键字建议大写 3种注释 单行注释: – 注释内容 或 # 注释内容(MySQL特有) 多行注释/* 注释*/ SQL分类 DDL:(操作数据库表) DML:(增删改表中的数据) DQL:(查询表中的数据) DCL:(授权–了解一下) DDL操作数据库.表 操作数据库: CRUD C(Create):创建 create database 数据库名称 create database if not exists判断数据库名称是否存在 create database 数据库名称 character set 字符集名 创建数据库判断是否有字符gbk create database if not exists db4 haracter set gbk; R(Retrieve):查询 :查看数据库的名称 show databases; :查看对应数据库的字符集 show create database mysql U(Update):修改 修改数据库的字符集 alter database数据库名称character set字符集名称 D(Delete):删除 drop database 数据库名称; drop database if exists 数据库名称 : 判断数据库是否存在在进行删除语法不会报错 使用数据库 查询当前正在使用的数据库名称 `select database(); 使用数据库 use 数据库名称 操作表 C(Create):创建 语法: create table表名(列名1 数据类型1, 列名2 数据类型2, ... 列名n 数据类型n ); 注意: 最后一列不需要加’逗号’(,) 数据类型: int类型 age int, double: 小数类型 score double(5.2) 小数类型 日期类型 date 只包含年月日, yyyy-MM-dd datetime 日期 包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值,或赋值为null则默认系统默认时间,来自动赋值 varchar:字符串类型 name varchar(20):姓名最大20个字符 –&gt;zhangsan 8个字符–张三 两个字符 创建表 create table student( id int, name varchar(32), age int, score double(4,1), birthday date, insert_time timestamp); R(Retrieve):查询 查询某个数据库中所有的名称 show tables 查询表结构 desc表名; 复制表: create table 表名 like 需要复制的表 U(Update):修改 修改表名 alter table 表名 rename to 新的表名 修改表的字符集 alter table 表名 charactor set 字符集名称 添加 一列 alter table 表名 add 列名 数据类型; 修改列的名称和类型 alter table 表名 change gender 新列名 新数据类型; alter table表名 modify 新表明 数据类型; 删除列 alter table 表名 drop 列名; D(Delete):删除 drop table 表名; drop table if exists 表名 ; 客户端图形化的工具: SQLYOg; DML:增删改表中的数据(重点) 添加数据: 语法: insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n); 注意事项: 列名和值要一一对应; 如果表名后不定义列名,则默认给所有列添加值 除了数字类型,其他类型需要使用引号’’ 或 “” 引起来 删除数据: 语法: delete from 表名 [where 条件] 注意: 不加条件将删除表中的所有记录 delete from 表名; –不推荐 有多少条记录就汇之星多少次删除操作. truncate table表名 –推荐使用,先删除表,然后在创建一张一模一样的表. 修改数据: 语法: update表名set列名1 = 值1,列名2 = 值2,…[while 条件] 注意: 如果不加任何条件将会将表中所有记录全部修改 DQL: 查询表中的记录 select *from表名 语法: select 字段名列表 from表名列表 where条件列表 group分组字段 having分组之后的条件 order by排序 limit分页限定 基础查询 多个字段查询 select 字段名1，字段名2，…from 表明 注意: 如果使用所有字段可以使用* 替换所有字段列表 去除重复 distinct 计算列 一般可以使用四则用算来计算列的值（一般只会进行数值型计算） ifnull(表达式1，表达式2，)： 表达式1： 那个字段要判断是否为null 表达式2：如果该字段为null后的替换值 起别名 as名字 也可以空格加取得名字 条件查询 where 字句后跟条件 运算符： 、&lt;、&lt;=、&gt;=、=、&lt;&gt; BETWEEN...AND iN(集合) LIKE ‘张%’ —-&gt; 后期用的会多一下 占位符： _单个任意字符 %多个任意字符 – 查询班级里面姓马的？select * from stu where name like &#39;马%&#39;; – 查询第二个字是化的人 select * from stu where name like &#39;_化%&#39;; – 查询姓名是3个字的人 select * from stu where name like &#39;___&#39;; – 查询姓名中包含马的人 select * from stu where name like &#39;%马%&#39;; IS NULL and 或 &amp;&amp; or 或 || not 或 !]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>DDL</tag>
        <tag>DML</tag>
        <tag>DQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础加强]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Junit单元测试: 测试分类: 黑河测试:不需要写代码,给输入值,看程序是否能够输出期望的值 白合测试:需要谢代码.关注程序具体的执行流程 Junit使用:白盒测试 步骤: 定义一个测试类(测试用例) 建议: 测试类名:被测试的类名Text —&gt; CalculatorText 包名:xxx.xxx.xx.text —&gt;cn.itcast.text 定义测试 : 可独立运行 建议: 方法名: text测试方法名 —&gt;textAdd() 返回值:void 参数列表:空参 给方法加注解@text 导入junit依赖环境 判定结果: 红色代表失败 绿色代表成功 一般我们会使用断言操作来处理结果 Assert.assertEquals(你期望的结果,运算的结果) 补充: @Before: 修饰的方法会在测试方法之前会被自动执行 @After: 不管有没有出现错误,最后都执行 ##反射: 框架设计的灵魂 框架: 半成品软件.可以在框架的基础上进行软甲开发,简化代码 概念: 将类的各个组成部分封装为其他对象,这就是反射机制 好处: 可以在程序运行过程中,操作这些对象 可以解耦,提高程序的课扩展性. 获取Class类的三种方式 Class.forName(“全类名”):将字节码文件加载进内存,返回Class文件 多数用于配置文件,将类名定义在配置文件中.读取文件加载类 类名.Class通过类名的属性Class获取 多用于参数的传递 对象.getClass():getClass()方法在Object类名中定义着 多用于对象获取字节码文件 结论: 同一个字节码文件(*.class)在第一次运行程序过程中,只会被加载一次,不论通过哪一种方式获取的Class对象都是同一个 Class对象功能: 获取功能: 获取成员变量 File[] getFiles() —&gt;获取的是public修饰的成员变量 File[] getFiled(String name) —&gt;获取指定名称的是public修饰的成员变量 File[] getDeclaredFileds() File[] getDeclaredFiled(String nane) 获取构造方法 * `Constructor&lt;?&gt;[] getConstructors()` * `Constructor&lt;T&gt; getConstructor(类&lt;?&gt;...parameterTypes)` * `Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;...parameterTypes)` * `Constructor&lt;?&gt;[] getDeclaredConstructors()` 获取成员方法 method[] getMethods() method getMethod(String name,类&lt;?&gt;...parameterTypes) method[] getDeclaredMethods() meth0d getDeclaredMethod(String name,类&lt;?&gt;...parameterTypes) 获取类名 String getName() Filed成员变量 操作: 设置值 void set(Object obj, Object value) 获取值 get(Object obj) 忽略访问权限服的安全检查 setAccessible(true) –&gt;暴力反射 Constructor: 构造方法 创建对象: T newInstance(Object...intargs) 如果使用空参数构造方法穿件对象,操作可以简化: Class对象的newInstance methhod:方法对象 执行方法: *Object invoke(Object obj,Object...args); 获取方法名 String getName() —&gt;获取方法名称 注解: 概念: 说明程序的. 给计算看的 注释: 用文字描述程序. 给程序员看的 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特 性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等 的前面，用来对这些元素进行说明，注释。 作用分类： ①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 ② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 ③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 JDK中预定的一些注解 @Override :检测被改注解标注的方法是否继承父类的 @Deprecated ：将该注解标注的内容已过时 @Suppresswarnings ：压制警告 —&gt; 参数一般传递&quot;all&quot; 自定义注解 格式 元注解 public @interface 注解名称{ 属性列表 } 本质 ：本质是就是一个接口，该接口默认继承Annotation public interface MyAnno extends java.lang.annotation.Annotation {} 属性 ：接口里可以注解的方法 – 成员属性 要求 属性的返回值类型 基本数据类型 String 枚举 注解 以上类型的数组 定义了属性，在使用时要给属性赋值 如果定义属性时,使用default关键字给属性初始化值,则使用注解时,可以不进行属性的赋值 如果只有 一个属性需要赋值,并且属性的名称是value可以直接赋值. 数组赋值时,值用{}包裹,如果数组中只有一个值大括号可以省略 元注解 :描述注解的注解 @Target: 描述注解能够作用的位置 ElementType取值: 可以作用于类上 METHOD可以作用于方法上* `FIELD`可以作用于成员变量上 @Retention: 描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME):当前被描述的注解,会保留到Class文件中,被字节码读取到 @Documented: 描述注解是否被抽取到api文档中 @Inherited: 描述注解是否被子类继承 在程序使用(解析)注解 获取注解定义的位置的对象 (Class, Method, Field) 获取指定的注解 getannotation(class) 调用注解中的抽象方法获取配置的属性值 小结： 以后大多数时候会使用注解，而不是自定义注解 注解给谁用？ 编译器 解析程序用 注解不是我们程序的一部分，理解为（标签）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>框架基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux笔记]]></title>
    <url>%2F2019%2F06%2F19%2FLinux%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[批量安装rpm包1rpm -ivh mysql-* 查询进程 1ps -ef |grep tomcat]]></content>
      <categories>
        <category>CentOS7</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装MySQL8.0.16]]></title>
    <url>%2F2019%2F06%2F19%2FLinux%E4%B8%8B%E5%AE%89%E8%A3%85MySQL8.0.16%2F</url>
    <content type="text"><![CDATA[引用Linux安装以及使用 注意安装时有需要配置忽略大小写一定要在第一次启动前配置 MySQL8忽略大小写 查找安装路径123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155[root@root ~]# rpm -qa|grep mysqlmysql-community-client-8.0.16-2.el7.x86_64mysql-community-libs-8.0.16-2.el7.x86_64mysql-community-libs-compat-8.0.16-2.el7.x86_64mysql-community-common-8.0.16-2.el7.x86_64mysql-community-server-8.0.16-2.el7.x86_64[root@root ~]# rpm -ql mysql-community-server-8.0.16-2.el7.x86_64/etc/logrotate.d/mysql/etc/my.cnf/etc/my.cnf.d/usr/bin/ibd2sdi/usr/bin/innochecksum/usr/bin/lz4_decompress/usr/bin/my_print_defaults/usr/bin/myisam_ftdump/usr/bin/myisamchk/usr/bin/myisamlog/usr/bin/myisampack/usr/bin/mysql_secure_installation/usr/bin/mysql_ssl_rsa_setup/usr/bin/mysql_tzinfo_to_sql/usr/bin/mysql_upgrade/usr/bin/mysqld_pre_systemd/usr/bin/mysqldumpslow/usr/bin/perror/usr/bin/zlib_decompress/usr/lib/systemd/system/mysqld.service/usr/lib/systemd/system/mysqld@.service/usr/lib/tmpfiles.d/mysql.conf/usr/lib64/mysql/mecab/usr/lib64/mysql/mecab/dic/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/char.bin/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/dicrc/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/left-id.def/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/matrix.bin/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/pos-id.def/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/rewrite.def/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/right-id.def/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/sys.dic/usr/lib64/mysql/mecab/dic/ipadic_euc-jp/unk.dic/usr/lib64/mysql/mecab/dic/ipadic_sjis/usr/lib64/mysql/mecab/dic/ipadic_sjis/char.bin/usr/lib64/mysql/mecab/dic/ipadic_sjis/dicrc/usr/lib64/mysql/mecab/dic/ipadic_sjis/left-id.def/usr/lib64/mysql/mecab/dic/ipadic_sjis/matrix.bin/usr/lib64/mysql/mecab/dic/ipadic_sjis/pos-id.def/usr/lib64/mysql/mecab/dic/ipadic_sjis/rewrite.def/usr/lib64/mysql/mecab/dic/ipadic_sjis/right-id.def/usr/lib64/mysql/mecab/dic/ipadic_sjis/sys.dic/usr/lib64/mysql/mecab/dic/ipadic_sjis/unk.dic/usr/lib64/mysql/mecab/dic/ipadic_utf-8/usr/lib64/mysql/mecab/dic/ipadic_utf-8/char.bin/usr/lib64/mysql/mecab/dic/ipadic_utf-8/dicrc/usr/lib64/mysql/mecab/dic/ipadic_utf-8/left-id.def/usr/lib64/mysql/mecab/dic/ipadic_utf-8/matrix.bin/usr/lib64/mysql/mecab/dic/ipadic_utf-8/pos-id.def/usr/lib64/mysql/mecab/dic/ipadic_utf-8/rewrite.def/usr/lib64/mysql/mecab/dic/ipadic_utf-8/right-id.def/usr/lib64/mysql/mecab/dic/ipadic_utf-8/sys.dic/usr/lib64/mysql/mecab/dic/ipadic_utf-8/unk.dic/usr/lib64/mysql/mecab/etc/usr/lib64/mysql/mecab/etc/mecabrc/usr/lib64/mysql/plugin/usr/lib64/mysql/plugin/adt_null.so/usr/lib64/mysql/plugin/auth_socket.so/usr/lib64/mysql/plugin/authentication_ldap_sasl_client.so/usr/lib64/mysql/plugin/component_audit_api_message_emit.so/usr/lib64/mysql/plugin/component_log_filter_dragnet.so/usr/lib64/mysql/plugin/component_log_sink_json.so/usr/lib64/mysql/plugin/component_log_sink_syseventlog.so/usr/lib64/mysql/plugin/component_validate_password.so/usr/lib64/mysql/plugin/connection_control.so/usr/lib64/mysql/plugin/ddl_rewriter.so/usr/lib64/mysql/plugin/debug/usr/lib64/mysql/plugin/debug/adt_null.so/usr/lib64/mysql/plugin/debug/auth_socket.so/usr/lib64/mysql/plugin/debug/authentication_ldap_sasl_client.so/usr/lib64/mysql/plugin/debug/component_audit_api_message_emit.so/usr/lib64/mysql/plugin/debug/component_log_filter_dragnet.so/usr/lib64/mysql/plugin/debug/component_log_sink_json.so/usr/lib64/mysql/plugin/debug/component_log_sink_syseventlog.so/usr/lib64/mysql/plugin/debug/component_validate_password.so/usr/lib64/mysql/plugin/debug/connection_control.so/usr/lib64/mysql/plugin/debug/ddl_rewriter.so/usr/lib64/mysql/plugin/debug/group_replication.so/usr/lib64/mysql/plugin/debug/ha_example.so/usr/lib64/mysql/plugin/debug/ha_mock.so/usr/lib64/mysql/plugin/debug/innodb_engine.so/usr/lib64/mysql/plugin/debug/keyring_file.so/usr/lib64/mysql/plugin/debug/keyring_udf.so/usr/lib64/mysql/plugin/debug/libmemcached.so/usr/lib64/mysql/plugin/debug/libpluginmecab.so/usr/lib64/mysql/plugin/debug/locking_service.so/usr/lib64/mysql/plugin/debug/mypluglib.so/usr/lib64/mysql/plugin/debug/mysql_no_login.so/usr/lib64/mysql/plugin/debug/rewrite_example.so/usr/lib64/mysql/plugin/debug/rewriter.so/usr/lib64/mysql/plugin/debug/semisync_master.so/usr/lib64/mysql/plugin/debug/semisync_slave.so/usr/lib64/mysql/plugin/debug/validate_password.so/usr/lib64/mysql/plugin/debug/version_token.so/usr/lib64/mysql/plugin/group_replication.so/usr/lib64/mysql/plugin/ha_example.so/usr/lib64/mysql/plugin/ha_mock.so/usr/lib64/mysql/plugin/innodb_engine.so/usr/lib64/mysql/plugin/keyring_file.so/usr/lib64/mysql/plugin/keyring_udf.so/usr/lib64/mysql/plugin/libmemcached.so/usr/lib64/mysql/plugin/libpluginmecab.so/usr/lib64/mysql/plugin/locking_service.so/usr/lib64/mysql/plugin/mypluglib.so/usr/lib64/mysql/plugin/mysql_no_login.so/usr/lib64/mysql/plugin/rewrite_example.so/usr/lib64/mysql/plugin/rewriter.so/usr/lib64/mysql/plugin/semisync_master.so/usr/lib64/mysql/plugin/semisync_slave.so/usr/lib64/mysql/plugin/validate_password.so/usr/lib64/mysql/plugin/version_token.so/usr/sbin/mysqld/usr/sbin/mysqld-debug/usr/share/doc/mysql-community-server-8.0.16/usr/share/doc/mysql-community-server-8.0.16/INFO_BIN/usr/share/doc/mysql-community-server-8.0.16/INFO_SRC/usr/share/doc/mysql-community-server-8.0.16/LICENSE/usr/share/doc/mysql-community-server-8.0.16/README/usr/share/man/man1/ibd2sdi.1.gz/usr/share/man/man1/innochecksum.1.gz/usr/share/man/man1/lz4_decompress.1.gz/usr/share/man/man1/my_print_defaults.1.gz/usr/share/man/man1/myisam_ftdump.1.gz/usr/share/man/man1/myisamchk.1.gz/usr/share/man/man1/myisamlog.1.gz/usr/share/man/man1/myisampack.1.gz/usr/share/man/man1/mysql.server.1.gz/usr/share/man/man1/mysql_secure_installation.1.gz/usr/share/man/man1/mysql_ssl_rsa_setup.1.gz/usr/share/man/man1/mysql_tzinfo_to_sql.1.gz/usr/share/man/man1/mysql_upgrade.1.gz/usr/share/man/man1/mysqldumpslow.1.gz/usr/share/man/man1/mysqlman.1.gz/usr/share/man/man1/perror.1.gz/usr/share/man/man1/zlib_decompress.1.gz/usr/share/man/man8/mysqld.8.gz/usr/share/mysql-8.0/dictionary.txt/usr/share/mysql-8.0/innodb_memcached_config.sql/usr/share/mysql-8.0/install_rewriter.sql/usr/share/mysql-8.0/mysql-log-rotate/usr/share/mysql-8.0/uninstall_rewriter.sql/var/lib/mysql/var/lib/mysql-files/var/lib/mysql-keyring/var/run/mysqld[root@root ~]# 查看端口是否开放查看端口是否开放1firewall-cmd --query-port=3306/tcp --zone=public 返回no即未开启，显示yes为已开启。12[root@voda ~]# firewall-cmd --query-port=3306/tcp --zone=public yes 开启端口1firewall-cmd --zone=public --add-port=3306/tcp --permanent 重新加载1firewall-cmd --reload 查看已经打开的端口1firewall-cmd --zone=public --list-ports 1234[root@voda ~]# firewall-cmd --query-port=3306/tcp --zone=publicFirewallD is not running#说明防火墙没有开启 防火墙操作命令12345systemctl status firewalld #查看firewalld状态systemctl stop firewalld #停止firewalldsystemctl start firewalld #开启firewalldsystemctl enable firewalld #开机自启动systemctl disable firewalld #禁止自启动]]></content>
      <categories>
        <category>CentOS7</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装后配置]]></title>
    <url>%2F2019%2F06%2F19%2FMySQL%E5%AE%89%E8%A3%85%E5%90%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[首先查看是否只允许本地连接 1cat /var/log/mysqld.log | grep password 1mysql -u root -p 1select user,host from user; localhost代表只允许本地连接不允许其他地址链接我们要修改成% 切换mysql数据库 1use mysql; 如果是刚刚装的数据没有修改过密码就要更改密码之后在操作 1ALTER USER USER() IDENTIFIED BY 'VodeDB@110'; 修改host值()此处不修改除本机其他地址链接时会出现10038,%代表其他地址 123update user set host = '%' where user = 'root';--刷新flush privileges; ###查看host值 1select user,host from user; 更改加密方式(可不做此操作)这里上面host是%我们就用&#39;root&#39;@&#39;%&#39;,是localhost我们就用&#39;root&#39;@&#39;localhost&#39; 1alter user 'root'@'%' identified by 'VodeDB@110' password expire never; 密码一定要符合规则否则出现ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 更新密码更改过host值之后必须更新密码,如果不更新会有1251错误出现 1alter user 'root'@'%' identified with mysql_native_password by 'VodeDB@110'; 12--刷新flush privileges;]]></content>
      <categories>
        <category>CentOS7</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
